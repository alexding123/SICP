#lang sicp
(define (accumulate op init seqs)
  (if (null? seqs)
      init
      (op (car seqs)
          (accumulate op init (cdr seqs)))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (enumerate-interval start end)
  (if (< end start)
      nil
      (cons start (enumerate-interval (+ start 1) end))))
(define (unique-pairs n)
  (define mySet (enumerate-interval 1 n))
  (flatmap (lambda (num)
             (map
              (lambda (x) (list num x))
              (enumerate-interval 1 (- num 1))))
           mySet))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (* test-divisor test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (filter pred items)
  (define (conditionCons front back)
    (if (pred front)
        (cons front back)
        back))
  (accumulate conditionCons (list) items))
(define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum? (unique-pairs n))))
;testing
(prime-sum-pairs 10) 