#lang sicp
; routine
(define global-array '())

(define (contents datum)
    (cond ((pair? datum) (cdr datum))
          ((number? datum) datum)
          (else (display "Bad tagged datum -- CONTENTS" datum))))
(define (make-entry k v) (list k v))
(define (key entry) (car entry))
(define (value entry) (cadr entry))

(define (type-tag datum)
    (cond ((pair? datum) (car datum))
          ((number? datum) 'scheme-number)
          (else (display "Bad tagged datum -- TYPE-TAG" datum))))
(define (put op type item)
  (define (put-helper k array)
    (cond ((null? array) (list(make-entry k item)))
          ((equal? (key (car array)) k) array)
          (else (cons (car array) (put-helper k (cdr array))))))
  (set! global-array (put-helper (list op type) global-array)))

(define (get op type)
  (define (get-helper k array)
    (cond ((null? array) #f)
          ((equal? (key (car array)) k) (value (car array)))
          (else (get-helper k (cdr array)))))
  (get-helper (list op type) global-array))
(define (level type) 
   (cond ((eq? type 'integer) 0) 
         ((eq? type 'rational) 1) 
         ((eq? type 'real) 2) 
         ((eq? type 'complex) 3) 
         (else (display "Invalid type -- LEVEL" type))))

(define (raise-to desired-arg arg)
  (if (< (level arg) (level desired-arg))
      (let ((raise (get 'raise (type-tag arg))))
        (raise-to (raise arg) desired-arg))
      arg))
(define (highest-level args)
  (if (null? args)
      (display "no argument given -- HIGHEST-LEVEL")
      (if (null? (cdr args))
          (car args)
          (highest-level (cons (if (> (level (car args)) (level (cadr args))) (car args) (cadr args)) (cddr args))))))
; solution
(define (drop x)
  (let ((lower-level (project x)))
    (if lower-level
        (if ((get 'equ? (type-tag x)) ((get 'raise (type-tag lower-level)) lower-level) lower-level)
            (drop lower-level)
            x)
        x)))
(define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
        (let ((proc (get op type-tags)))
            (if proc
                (drop (apply proc (map contents args)))
                (let ((highest (highest-level type-tags)))
                  (let ((raised (map (raise-to highest) args)))
                    (let ((new-proc (get op (map type-tag raised))))
                      (if new-proc
                          (drop (apply new-proc (map contents raised)))
                          (display "No method for these types -- APPLY-GENERIC" (list op type-tags))
                   ))))))))
(define (project x)
  (if (= (level x) 0)
      #f
      (apply-generic 'project x)))